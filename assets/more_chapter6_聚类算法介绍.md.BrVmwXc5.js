import{_ as l,o as e,c as i,ag as t}from"./chunks/framework.CzE6cJJL.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"more/chapter6/聚类算法介绍.md","filePath":"more/chapter6/聚类算法介绍.md","lastUpdated":1766999133000}'),r={name:"more/chapter6/聚类算法介绍.md"};function p(o,a,n,s,h,m){return e(),i("div",null,[...a[0]||(a[0]=[t('<h3 id="关于两种聚类算法" tabindex="-1">关于两种聚类算法 <a class="header-anchor" href="#关于两种聚类算法" aria-label="Permalink to &quot;关于两种聚类算法&quot;">​</a></h3><p><strong>K-Means</strong> k-means是一种基于划分的聚类算法，主要思想是把数据划分到k个簇，每个簇都有中心点。 该算法速度快，形成的簇近似于球形，适合于大量的、简单的、规则的数据集。</p><ol><li>用户选择簇的数量</li><li>随机选择K个点作为中心点</li><li>将每个样本分配到距离最近的质心所在的簇</li><li>对每个簇重新计算所有成员的平均值作为新的质心</li><li>重复步骤3和4，直到质心不在变化或者到达最大的迭代次数</li></ol><p><strong>原理：</strong> k-means 的核心思想是，把数据分成 k 个群组（也叫簇），每个群组都有一个“中心点”（也叫质心），目标是让每个点都尽可能靠近自己群组的中心点。简单来说，就是“物以类聚，人以群分”。</p><p><strong>步骤：</strong></p><p>选中心： 先随机选 k 个点，把它们当成初始的中心点。</p><p>分堆： 把每个数据点都分到离它最近的中心点所在的群组。</p><p>算中心： 重新计算每个群组的中心点（通常是这个群组里所有点的平均值）。</p><p>重复： 重复 “分堆” 和 “算中心” 这两步，直到中心点不再怎么变化，或者达到你设定的最大循环次数。</p><p><strong>HDBSCAN</strong> HDBSCAN聚类是一种基于密度的聚类算法。 该算法速度慢，形成的簇是任意形状的，但适合于复杂的、含噪声的数据集。</p><ol><li>通过最小样本数和最小簇大小来估计每个点的密度，也就是看这个点周围有多少邻居</li><li>基于点之间的距离和密度关系构建最小生成树，代表两个点的距离</li><li>通过不断的切割形成不同密度的簇，也就是说切割哪些距离很长的边（距离很远的点），哪些怎么都连接不上的点就是噪声点</li><li>HDBSCAN算法可以自动判断分几组，还会自动判断哪些组最稳定</li></ol><p><strong>核心概念：</strong></p><p>核心距离： 对于每个点，找到包含至少 minPts 个点的最小半径，这个半径就是该点的核心距离。</p><p>可达距离： 点 A 到点 B 的可达距离是：点 B 的核心距离 和 A 到 B 的实际距离，两者取最大值。</p><p>互达性图： 基于可达距离构建的图，距离越小，连接越紧密。</p><p>簇的提取： 通过在互达性图上进行聚类，提取簇。</p><p><strong>步骤（简化版）：</strong></p><p>算密度： 评估每个点周围的密度。</p><p>建树： 构建一个层次聚类树，把密度相近的点放在一起。</p><p>剪枝： 根据密度和连通性，对聚类树进行剪枝，去除噪声和不稳定的簇。</p><p>提取簇： 从剪枝后的树中提取最终的簇。</p><p>请理解聚类的概念,可以参考哔哩哔哩中zilliz的讲解视频,在二维平面上,运用聚类算法可以更好的将相似的数据聚在一起，从而提高检索性能。</p><h3 id="关于聚类的时机" tabindex="-1">关于聚类的时机 <a class="header-anchor" href="#关于聚类的时机" aria-label="Permalink to &quot;关于聚类的时机&quot;">​</a></h3><p>下面有三种使用聚类算法的时机：</p><ol><li>如果检索性能是首要目标： <ul><li>在数据存储时进行聚类，并将聚类标签存储到数据库中。</li><li>检索时直接利用聚类标签快速定位相关数据</li></ul></li><li>如果数据动态变化比较频繁： <ul><li>在检索时对召回的数据进行分类，动态分析数据分布</li></ul></li><li>如果需要离线数据分析 <ul><li>定期对数据进行聚类，用于分析或推荐系统</li></ul></li></ol><h3 id="关于k-means聚类算法的详解" tabindex="-1">关于K-means聚类算法的详解 <a class="header-anchor" href="#关于k-means聚类算法的详解" aria-label="Permalink to &quot;关于K-means聚类算法的详解&quot;">​</a></h3><p>这一部分将非常多，主要包含论文的解读和分析，如果你对聚类算法感兴趣，可以去看这一部分：<a href="./../chapter4/K-mean算法详解.html">K-means聚类算法详解</a>(已删除)，他可以为你的项目优化提供一些优化的思路，但如果你只是想了解，那么你看完这个介绍部分就行了。</p><h3 id="final" tabindex="-1">Final <a class="header-anchor" href="#final" aria-label="Permalink to &quot;Final&quot;">​</a></h3><p>感谢读完！🎉 这一部分大部分都是文字，如果你想要看到效果，请前往<a href="./../project/Cre_milvus/readme.html">Cre_milvus</a>实践项目，在这个项目中，将会实际的为您展示聚类的实际效果，同样的如果您觉得刚刚的这个Cre_milvus太慢了（向量化没有调用什么API，将非常消耗CPU和内存，会让你的电脑风扇嗷嗷叫），你可以选择在<a href="./../project/HDBSCAN.html">HDBSCAN</a>这个项目中更快的看到聚类效果！</p>',29)])])}const d=l(r,[["render",p]]);export{c as __pageData,d as default};
