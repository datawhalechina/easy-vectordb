import{_ as e,c,o as d,ag as t}from"./chunks/framework.iC72KZN-.js";const u=JSON.parse('{"title":"An efficient K-means clustering algorithm for massive data论文详解","description":"","frontmatter":{},"headers":[],"relativePath":"Milvus/chapter4/K-mean算法详解.md","filePath":"Milvus/chapter4/K-mean算法详解.md","lastUpdated":1752663749000}'),l={name:"Milvus/chapter4/K-mean算法详解.md"};function r(n,o,s,i,g,a){return d(),c("div",null,[...o[0]||(o[0]=[t('<h1 id="an-efficient-k-means-clustering-algorithm-for-massive-data论文详解" tabindex="-1">An efficient K-means clustering algorithm for massive data论文详解 <a class="header-anchor" href="#an-efficient-k-means-clustering-algorithm-for-massive-data论文详解" aria-label="Permalink to &quot;An efficient K-means clustering algorithm for massive data论文详解&quot;">​</a></h1><p>关于这一部分，你将收获到K-means算法关于初始聚类点的计算以及优化方式，除此之外还有关于聚类边界的点集划分的计算。</p><p><strong>核心概念：快速判断一个数据块内的点是否都属于同一个聚类</strong></p><p>BWKM算法的核心目标之一是<strong>避免对每个数据点都进行K次距离计算</strong>（传统Lloyd算法需要）。它通过将数据空间划分为块(<code>Block</code>)，并利用块的整体几何属性质心信息，<strong>快速判断整个块内的点是否可能都属于同一个聚类</strong>。如果判断属于同一个聚类，那么该块内所有点都可以被整体分配给该聚类，无需再逐个点计算距离。这大大节省了计算量。</p><p><strong>定义解析：</strong></p><ol><li><p><strong>定义3：误分配函数 (ϵᴄ,ᴅ(B))</strong></p><ul><li><strong>输入:</strong><ul><li><code>C</code>: K个质心的集合。</li><li><code>D</code>: 数据集 (d维空间中的点)。</li><li><code>B</code>: 一个空间块 (比如一个矩形区域)。</li><li><code>P = B(D)</code>: 落在块<code>B</code>内的数据点的子集。如果<code>P</code>是空的(<code>∅</code>)，则误分配函数为0。</li></ul></li><li><strong>输出:</strong> <code>ϵᴄ,ᴅ(B)</code> - 一个非负实数，衡量块<code>B</code>内的点<em>可能</em>被错误分配到不同聚类的风险程度。</li><li><strong>计算公式:</strong><ul><li><code>ϵᴄ,ᴅ(B) = max{0, 2 * lʙ - δᴘ(C)}</code></li></ul></li><li><strong>公式组成:</strong><ul><li><code>lʙ</code>: 块<code>B</code><strong>对角线的长度</strong>。这代表了块<code>B</code>在空间中的<strong>最大可能跨度</strong>。块越大，<code>lʙ</code>越大。</li><li><code>δᴘ(C)</code>: <ul><li>设<code>P̄</code>是点集<code>P</code>的代表点（通常用<code>P</code>的质心，由加权Lloyd算法计算得出）。</li><li>设<code>cᴘ̄</code>是离<code>P̄</code><strong>最近</strong>的那个质心 (<code>cᴘ̄ ∈ C</code>)。</li><li><code>δᴘ(C) = min_{c ∈ C \\ {cᴘ̄}} ||P̄ - c|| - ||P̄ - cᴘ̄||</code></li><li><strong>解释:</strong><ul><li><code>||P̄ - cᴘ̄||</code> 是代表点<code>P̄</code>到其最近质心<code>cᴘ̄</code>的距离。</li><li><code>min_{c ∈ C \\ {cᴘ̄}} ||P̄ - c||</code> 是代表点<code>P̄</code>到<strong>除最近质心<code>cᴘ̄</code>外</strong>所有其他质心<code>c</code>中<strong>最小</strong>的距离（即到<strong>第二近质心</strong>的距离）。</li><li>所以，<code>δᴘ(C)</code> = (代表点<code>P̄</code>到第二近质心的距离) - (代表点<code>P̄</code>到最近质心的距离)。</li><li><strong>物理意义:</strong> <code>δᴘ(C)</code> <strong>衡量了最近质心<code>cᴘ̄</code>相对于其他质心对代表点<code>P̄</code>的“优势”有多大</strong>。<code>δᴘ(C)</code>越大，说明<code>cᴘ̄</code>比第二近的质心离<code>P̄</code>近很多，<code>P̄</code>属于<code>cᴘ̄</code>的确定性越高。</li></ul></li></ul></li></ul></li><li><strong><code>2 * lʙ - δᴘ(C)</code> 的含义:</strong><ul><li><code>2 * lʙ</code>: 这是块<code>B</code>内任意两点之间<strong>最大可能距离</strong>的上限（根据三角不等式，块内任意两点距离不会超过对角线长度<code>lʙ</code>，但乘以2提供了一个更宽松的、更容易计算的上界）。</li><li><code>δᴘ(C)</code>: 如上所述，是最近质心<code>cᴘ̄</code>对<code>P̄</code>的优势程度。</li><li><strong>整个项 <code>2 * lʙ - δᴘ(C)</code> 的含义:</strong> 想象块<code>B</code>内有一个点<code>x</code>，它可能离代表点<code>P̄</code>很远（最远可达<code>lʙ</code>量级）。如果块<code>B</code>非常大(<code>lʙ</code>很大)，或者<code>cᴘ̄</code>的优势很小(<code>δᴘ(C)</code>很小)，那么<code>x</code>离<code>P̄</code>的距离可能会抵消<code>cᴘ̄</code>相对于其他质心对<code>P̄</code>的优势，使得<code>x</code>有可能被分配到<code>cᴘ̄</code>以外的其他质心（比如第二近的质心）。<code>2 * lʙ - δᴘ(C)</code> 这个值<strong>量化了这种风险</strong>。</li></ul></li><li><strong><code>max{0, ...}</code> 的含义:</strong> 如果<code>2 * lʙ - δᴘ(C)</code>小于或等于0，说明即使考虑块内离<code>P̄</code>最远的点，<code>cᴘ̄</code>的优势仍然足够大，<strong>理论上可以保证</strong>块内所有点都应该分配给<code>cᴘ̄</code>。此时<code>ϵ=0</code>。如果<code>2 * lʙ - δᴘ(C) &gt; 0</code>，则存在<strong>风险</strong>，块内可能有点不属于<code>cᴘ̄</code>。风险越大，<code>ϵ</code>值越大。</li><li><strong>总结 <code>ϵᴄ,ᴅ(B)</code> 的作用:</strong> 它是一个<strong>风险指示器</strong>。<code>ϵ=0</code> 表示块<code>B</code>内所有点<strong>一定</strong>都属于同一个聚类（即<code>cᴘ̄</code>）。<code>ϵ&gt;0</code> 表示块<code>B</code>内<strong>可能</strong>有点属于不同的聚类，<code>ϵ</code>值越大，这种可能性越高（启发式规则）。</li></ul></li><li><p><strong>定理1：误分配函数为0的意义</strong></p><ul><li><strong>陈述:</strong> 如果对于一个非空的块<code>B</code>（包含点集<code>P</code>），计算出的误分配函数 <code>ϵᴄ,ᴅ(B) = 0</code>，那么<strong>块<code>B</code>内每一个点<code>x</code>的最近质心<code>cₓ</code>，都等于代表点<code>P̄</code>的最近质心<code>cᴘ̄</code></strong>。即：所有点<code>x ∈ P</code>都属于同一个聚类<code>cᴘ̄</code>。</li><li><strong>重要性:</strong> 这是BWKM算法高效性的<strong>理论基础</strong>。它证明了仅利用块<code>B</code>的几何信息(<code>lʙ</code>)、代表点<code>P̄</code>（由加权Lloyd提供）和质心<code>C</code>，通过计算<code>ϵ</code>，<strong>无需检查块内任何一个具体数据点<code>x</code>的距离</strong>，就能<strong>绝对确定</strong>整个块<code>B</code>内的点都属于同一个聚类<code>cᴘ̄</code>。这是算法能跳过大量距离计算的关键。</li></ul></li><li><p><strong>定义4：边界 (ℱᴄ,ᴅ(ℬ))</strong></p><ul><li><strong>输入:</strong><ul><li><code>D</code>: 数据集。</li><li><code>C</code>: 质心集合。</li><li><code>ℬ</code>: 一个空间划分（由许多块<code>B</code>组成）。</li></ul></li><li><strong>输出:</strong> <code>ℱᴄ,ᴅ(ℬ)</code> - 当前划分<code>ℬ</code>的<strong>边界</strong>。</li><li><strong>定义:</strong> 边界 <code>ℱᴄ,ᴅ(ℬ)</code> 是划分<code>ℬ</code>中所有满足 <code>ϵᴄ,ᴅ(B) &gt; 0</code> 的块<code>B</code>组成的子集。</li><li><strong>意义:</strong> 边界包含了所有<strong>可能没有被正确分配</strong>（即内部点可能属于不同聚类）的块。这些块是算法需要进一步关注和处理的对象。</li><li><strong>算法中的应用 (BWKM的核心策略):</strong> BWKM算法在运行过程中会维护一个空间划分<code>ℬ</code>。它<strong>只对边界块(<code>ℱᴄ,ᴅ(ℬ)</code>中的块)进行分割细化</strong>。如果一个块<code>B</code>的<code>ϵ=0</code>（不在边界上），那么它就被认为是“安全”的，其内部所有点都被整体分配给<code>cᴘ̄</code>，算法在后续迭代中不会再处理这个块内部（除非质心移动导致<code>ϵ</code>重新大于0）。这个策略<strong>极大地减少了需要细化和计算距离的块的数量</strong>，从而提高了效率。</li></ul></li></ol><p><strong>图1解释:</strong></p><p>图中展示了一个具体的块<code>B</code>（黑色边框矩形），内部有红蓝两色的点（属于两个不同的聚类，质心用蓝色星星表示）。代表点<code>P̄</code>是紫色菱形。</p><ul><li><strong>计算 <code>ϵᴄ,ᴅ(B)</code> 需要的信息 (图中所示):</strong><ul><li><code>||P̄ - cᴘ̄||</code>: 紫色菱形(<code>P̄</code>)到离它最近的蓝色星星(<code>cᴘ̄</code>)的距离（一条蓝色虚线）。</li><li><code>min_{c ∈ C \\ {cᴘ̄}} ||P̄ - c||</code>: 紫色菱形(<code>P̄</code>)到另一个（第二近的）蓝色星星的距离（另一条蓝色虚线）。在这个例子中，<code>cᴘ̄</code>和这个第二近质心正好是那两个蓝色星星。</li><li><code>δᴘ(C) = min_{c ∈ C \\ {cᴘ̄}} ||P̄ - c|| - ||P̄ - cᴘ̄||</code>: 两条蓝色虚线长度的差值。</li><li><code>lʙ</code>: 块<code>B</code>的紫色对角线长度（紫色虚线）。</li></ul></li><li><strong>为什么 <code>ϵ &gt; 0</code>?</strong> 块内实际包含了属于两个不同聚类的点（红点和蓝点）。代表点<code>P̄</code>可能靠近块中心或某个质心，但块的范围(<code>lʙ</code>)足够大，包含了靠近另一个质心的区域（图中右上角的红点离右边的蓝色星星更近）。计算出来的 <code>2 * lʙ</code> 大于 <code>δᴘ(C)</code>，导致 <code>ϵ = 2 * lʙ - δᴘ(C) &gt; 0</code>。这正确地反映了该块没有被“完好分配”（well assigned）的风险/事实，因此它会被包含在边界<code>ℱ</code>中，需要被进一步分割。</li></ul><p><strong>总结:</strong></p><ol><li><strong>误分配函数 <code>ϵ</code></strong>：是一个利用块几何大小(<code>lʙ</code>)、代表点(<code>P̄</code>)和质心(<code>C</code>)计算出来的值，用于评估块内点是否可能属于不同聚类。</li><li><strong>定理1</strong>：<code>ϵ=0</code> 是块内所有点必然属于同一聚类的<strong>充分条件</strong>。这允许算法安全地跳过这些块内部的距离计算。</li><li><strong>边界 <code>ℱ</code></strong>：是所有 <code>ϵ&gt;0</code> 的块的集合。这些块需要进一步处理（分割细化）。</li><li><strong>BWKM算法策略</strong>：在每次迭代中，只对当前划分的**边界块(<code>ℱ</code>)**进行分割细化，并对这些细化后的块计算<code>ϵ</code>。对于<code>ϵ=0</code>的块，将其内所有点整体分配给<code>cᴘ̄</code>；对于<code>ϵ&gt;0</code>的块，保留在边界中等待下次迭代可能继续分割。同时，质心会根据当前分配更新。这个过程不断重复，边界越来越细，直到满足停止条件（如边界为空、迭代次数、质心变化小等）。</li><li><strong>优势</strong>：通过避免对<code>ϵ=0</code>的“安全”块进行内部点级的距离计算和检查，以及只关注边界块进行细化，BWKM显著减少了k-means迭代中所需的距离计算次数，从而加速了计算，尤其适合处理大规模数据集。</li></ol><h3 id="reference" tabindex="-1">Reference <a class="header-anchor" href="#reference" aria-label="Permalink to &quot;Reference&quot;">​</a></h3><p>[1] <a href="https://arxiv.org/abs/1801.02949" target="_blank" rel="noreferrer">An efficient K-means clustering algorithm for massive data</a></p>',13)])])}const P=e(l,[["render",r]]);export{u as __pageData,P as default};
